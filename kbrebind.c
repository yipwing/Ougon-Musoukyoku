#include <windows.h>

#include "dinput.h"

#include <stdio.h>
#include <stdlib.h>

struct key_entry_t {
	const char *	name;
	unsigned int	address;
	unsigned int	orig_address;
	unsigned int	key;
};

struct key_entry_t key_table[] = {
	{ "KeyUp",	0x5A09,		0x5A09,		DIK_UP		},
	{ "KeyDown",	0x5A1A,		0x5A1A,		DIK_DOWN	},
	{ "KeyLeft",	0x5A2B,		0x5A2B,		DIK_LEFT	},
	{ "KeyRight",	0x5A3C,		0x5A3C,		DIK_RIGHT	},
	{ "KeyA",	0x5A4D,		0x5A4D,		DIK_Z		},
	{ "KeyB",	0x5A5E,		0x5A5E,		DIK_X		},
	{ "KeyC",	0x5A6F,		0x5A6F,		DIK_C		},
	{ "KeyTouch",	0x5A80,		0x5A80,		DIK_S		},
	{ "KeyAppeal",	0x5A91,		0x5A91,		DIK_LSHIFT	},
	{ "KeyUnknown1",0x5A9F,		0x5A9F,		DIK_A		},
	{ "KeyUnknown2",0x5AB0,		0x5AB0,		DIK_D		},
	{ "KeyUnknown3",0x5AC1,		0x5AC1,		DIK_Q		},
	{ "KeyUnknown4",0x5AD2,		0x5AD2,		DIK_E		},
	{ "KeyStart",	0x5AE3,		0x5AE3,		DIK_W		},
	{ "KeyUnknown5",0x5AF4,		0x5AF4,		DIK_RETURN	},
	{ "KeyUnknown6",0x87013,	0x5B05,		DIK_RSHIFT	},
	{ "KeyAB",	0x86FB3,	0x0,		0		},
	{ "KeyBC",	0x86FD3,	0x0,		0		},
	{ "KeyABC",	0x86FE8,	0x0,		0		},
};

const unsigned char code_1[7] = {
	// JMP to lalala  // 跳到要修改的组合键位置
    0xe9,0xa9,0x14,0x08,0x00,0x90,0x90,
};

const unsigned int code_1_size = sizeof(code_1);
const unsigned int code_1_address = 0x5B03;

/*
	pre-v1.04 code
const unsigned char code_2[] = {
	// 461a60
	// CMP BYTE PTR SS:[EBP+xx], 0
	0x80, 0xbd, 0x00, 0x00, 0x00, 0x00, 0x00,
	// JE SHORT blahblah
	0x74, 0x08,
	// OR DWORD PTR SS:[ESP+14], 20 (AB)
	0x81, 0x4c, 0x24, 0x14, 0x20, 0x00, 0x00, 0x00,

	// 461a71
	// again, BC (0x40)
	0x80, 0xbd, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x74, 0x08,
	0x81, 0x4c, 0x24, 0x14, 0x40, 0x00, 0x00, 0x00,

	// 461a82
	// again, ABC (0x80)
	0x80, 0xbd, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x74, 0x08,
	0x81, 0x4c, 0x24, 0x14, 0x80, 0x00, 0x00, 0x00,

	// 461a93
	// CMP BYTE PTR SS:[EBP+75A], 0
	0x80, 0xbd, 0x5a, 0x07, 0x00, 0x00, 0x00,

	// 461a9a
	// JMP 40636a
	0xe9, 0xcb, 0x48, 0xfa, 0xff
};
 */

 /*
  * 1.10 code 这里是以前1.10的代码..
  const unsigned char code_2[] = {
	// 465b90 1.10 466170
	// RETN (original)
	0xc3,

	// 465b91       //466171
	// CMP BYTE PTR SS:[EBP+xx], 0
	0x80, 0xbd, 0x00, 0x00, 0x00, 0x00, 0x00,
	// JE SHORT blahblah
	0x74, 0x17,
	// JMP SHORT blah blah
	0xeb, 0x09,

	// original crap
	0xcc, 0xcc, 0xcc, 0xcc,
	0xe9, 0x1b, 0x20, 0xfa, 0xff, // JMP blah blah

	// OR DWORD PTR SS:[ESP+14], 20 (AB)
	0x83, 0x4c, 0x24, 0x14, 0x20,
	// JMP SHORT blahblah
	0xeb, 0x05,

	// original
	0xcc, 0xcc, 0xcc, 0xcc,
	0xc3, // RETN

	// 465bb1
	// again, BC (0x40)
	0x80, 0xbd, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x74, 0x0c,
	0xeb, 0x05,
	0xcc, 0xcc, 0xcc, 0xcc, 0xc3, // (orig)
	0x83, 0x4c, 0x24, 0x14, 0x40,

	// 461bc6
	// again, ABC (0x80)
	0x80, 0xbd, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xeb, 0x18,

	// orig stuff
	0xcc,
	0x68, 0xf0, 0x24, 0x44, 0x00,
	0x68, 0x10, 0x27, 0x00, 0x00,
	0x6a, 0x1c,
	0x68, 0xd4, 0xa9, 0x47, 0x00,
	0xe8, 0xb7, 0xb5, 0xfe, 0xff,
	0xc3,

	// 465be7, abc continued
	0x74, 0x07,
	0x81, 0x4c, 0x24, 0x14, 0x80, 0x00, 0x00, 0x00,

	// 465bf1
	// CMP BYTE PTR SS:[EBP+75A], 0
	0x80, 0xbd, 0x5a, 0x07, 0x00, 0x00, 0x00,

	// 465bf8
	// JMP 40653a // 跳回改过的地址
	//0xe9, 0x3d, 0x09, 0xfa, 0xff
	0xE9,  0x5D,  0x03,  0xFA,  0xFF,
};
*/
 // 2.0 位置..
const unsigned char code_2[] = {
	// 487bb1
	// RETN (original)  这里和前面基本上是一样的... 只是改动了少许原始码..
	0xc3,
	// CMP BYTE PTR SS:[EBP+xx], 0
	0x80, 0xBD, 0x00, 0x00, 0x00, 0x00, 0x00,
	// JE SHORT blahblah
	0x74, 0x17,
	// JMP SHORT blah blah
	0xeb, 0x09,

	// original crap
	0xcc, 0xcc, 0xcc, 0xcc,
	0xe9, 0x5b, 0x02, 0xf8, 0xff, // JMP blah blah

	// OR DWORD PTR SS:[ESP+14], 20 (AB)  
	0x83, 0x4c, 0x24, 0x14, 0x20,
	// JMP SHORT blahblah
	0xeb, 0x05,

	// original
	0xcc, 0xcc, 0xcc, 0xcc,
	0xc3, // RETN

	// 465bb1
	// again, BC (0x40)
	0x80, 0xBD, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x74, 0x0c,
	0xeb, 0x05,
	0xcc, 0xcc, 0xcc, 0xcc, 0xc3, // (orig)
	0x83, 0x4c, 0x24, 0x14, 0x40,

    0x80, 0xbd, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xeb, 0x18,

	// orig stuff
	0xcc,
	0x68, 0x30, 0xA6, 0x44, 0x00,
	0x68, 0x10, 0x27, 0x00, 0x00,
	0x6a, 0x1c,
	0x68, 0xA0, 0x17, 0x4B, 0x00,
	0xe8, 0xF7, 0x33, 0xfd, 0xff,
	0xc3,

    //abc continue
    0x74, 0x07,
    0x81, 0x4c, 0x24, 0x14, 0x80, 0x00, 0x00, 0x00,

    // CMP BYTE PTR SS:[EBP+75A], 0
	0x80, 0xbd, 0x5a, 0x07, 0x00, 0x00, 0x00,
	// JMP xxxxxx // 跳回改过的地址
	0xE9,  0xED,  0xEA,  0xF7,  0xFF,
};

const unsigned int code_2_size = sizeof(code_2);
const unsigned int code_2_address = 0x86FB0;	// 466170 // 487BB0

int key_table_size = sizeof(key_table)/sizeof(key_table[0]);

void run() {
	FILE *file = fopen("GameMain.exe", "rb");
	unsigned char *data;
	unsigned int size;
	int i;

	if (!file) {
		printf("阿拉，不能打开GameMain.exe\n");
		return;
	}

	fseek(file, 0, SEEK_END);
	size = ftell(file);
	fseek(file, 0, SEEK_SET);

	if (size < 0xb0000) {
		printf("不是一个有效的执行程序.\n");

		return;
	}

	data = malloc(size);
	fread(data, size, 1, file);

	fclose(file);

	/* verify that it is valid. */
	if (memcmp(data + 0x9982C, "CROSS", 5) != 0) {
		printf("这个改键程序只能改v2.00的黄金梦想曲.\n");

		free(data);
		return;
	}

	/* get all original keys */
	for (i = 0; i < key_table_size; ++i) {
		if (key_table[i].orig_address == 0) {
			continue;
		}

		key_table[i].key = *(unsigned int *)(data + key_table[i].orig_address) - 0x724; 
	}

	/* write new keybind code */
	memcpy(data + code_1_address, code_1, code_1_size);
	memcpy(data + code_2_address, code_2, code_2_size);

	/* update binds */
	for (i = 0; i < key_table_size; ++i) {
		unsigned int orig;
		if (key_table[i].address == 0) {
			continue;
		}

		orig = key_table[i].key;

		key_table[i].key = GetPrivateProfileInt("KEYS", key_table[i].name, key_table[i].key, "./kbrebind.ini");

		*(unsigned int *)(data + key_table[i].address) = key_table[i].key + 0x724;
		printf("%20s: %8x -> %8x\n", key_table[i].name, orig, *(unsigned int *)(data + key_table[i].address) - (0x724));
	}

	file = fopen("GameMain-kb.exe", "wb");
	if (file) {
		fwrite(data, size, 1, file);
		fclose(file);
	}

	printf("完成! GameMain-kb.exe 已经创建\n");
}

int main() {
	run();

	printf("按下回车键结束.\n");
	getchar();

	return 0;
}
